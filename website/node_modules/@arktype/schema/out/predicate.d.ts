import { type RegisteredReference } from "@arktype/util";
import type { constrain, of } from "./ast.js";
import { BaseConstraint } from "./constraint.js";
import type { errorContext } from "./kinds.js";
import type { NodeCompiler } from "./shared/compile.js";
import type { BaseMeta, declareNode } from "./shared/declare.js";
import { type nodeImplementationOf } from "./shared/implement.js";
import type { TraversalContext, TraverseAllows, TraverseApply } from "./shared/traversal.js";
export interface PredicateInner<rule extends Predicate<any> = Predicate<any>> extends BaseMeta {
    readonly predicate: rule;
}
export type PredicateErrorContext = Partial<PredicateInner>;
export type PredicateSchema = PredicateInner | Predicate<any>;
export interface PredicateDeclaration extends declareNode<{
    kind: "predicate";
    schema: PredicateSchema;
    normalizedSchema: PredicateInner;
    inner: PredicateInner;
    intersectionIsOpen: true;
    errorContext: PredicateErrorContext;
}> {
}
export declare const predicateImplementation: nodeImplementationOf<PredicateDeclaration>;
export declare class PredicateNode extends BaseConstraint<PredicateDeclaration> {
    serializedPredicate: RegisteredReference;
    compiledCondition: string;
    compiledNegation: string;
    impliedBasis: null;
    expression: string;
    traverseAllows: TraverseAllows;
    errorContext: errorContext<"predicate">;
    compiledErrorContext: string;
    traverseApply: TraverseApply;
    compile(js: NodeCompiler): void;
}
export type Predicate<data = unknown> = (data: data, ctx: TraversalContext) => boolean;
export type PredicateCast<input = never, narrowed extends input = input> = (input: input, ctx: TraversalContext) => input is narrowed;
export type inferNarrow<t, predicate> = predicate extends (data: any, ...args: any[]) => data is infer narrowed ? t extends of<unknown, infer constraints> ? constrain<of<narrowed, constraints>, "predicate", any> : constrain<narrowed, "predicate", any> : constrain<t, "predicate", any>;
