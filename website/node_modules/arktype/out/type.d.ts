import { ArkErrors, BaseRoot, type BaseMeta, type Disjoint, type InnerRoot, type Morph, type NodeSchema, type Out, type Predicate, type PrimitiveConstraintKind, type Root, type ambient, type constrain, type constraintKindOf, type distillIn, type distillOut, type includesMorphs, type inferIntersection, type inferMorphOut, type inferNarrow, type inferPipes, type internalImplementationOf } from "@arktype/schema";
import { Callable, type Constructor, type array, type conform } from "@arktype/util";
import { Generic, type validateParameterString } from "./generic.js";
import type { inferDefinition, validateDeclared, validateDefinition } from "./parser/definition.js";
import { parseGenericParams } from "./parser/generic.js";
import type { IndexOneOperator, IndexZeroOperator, TupleInfixOperator } from "./parser/tuple.js";
import type { RawScope, Scope, bindThis } from "./scope.js";
export interface TypeParserAttachments {
    errors: typeof ArkErrors;
}
export interface TypeParser<$> extends TypeParserAttachments {
    <const def>(def: validateTypeRoot<def, $>): Type<inferTypeRoot<def, $>, $>;
    <const zero, const one, const rest extends array>(_0: zero extends IndexZeroOperator ? zero : validateTypeRoot<zero, $>, _1: zero extends "keyof" ? validateTypeRoot<one, $> : zero extends "instanceof" ? conform<one, Constructor> : zero extends "===" ? conform<one, unknown> : conform<one, IndexOneOperator>, ..._2: zero extends "===" ? rest : zero extends "instanceof" ? conform<rest, readonly Constructor[]> : one extends TupleInfixOperator ? one extends ":" ? [Predicate<distillIn<inferTypeRoot<zero, $>>>] : one extends "=>" ? [Morph<distillOut<inferTypeRoot<zero, $>>, unknown>] : one extends "@" ? [string | BaseMeta] : [validateTypeRoot<rest[0], $>] : []): Type<inferTypeRoot<[zero, one, ...rest], $>, $>;
    <params extends string, const def>(params: `<${validateParameterString<params>}>`, def: validateDefinition<def, $, {
        [param in parseGenericParams<params>[number]]: unknown;
    }>): Generic<parseGenericParams<params>, def, $>;
}
export declare class RawTypeParser extends Callable<(...args: unknown[]) => BaseRoot | Generic, TypeParserAttachments> {
    constructor($: RawScope);
}
export type DeclarationParser<$> = <preinferred>() => {
    type: <def>(def: validateDeclared<preinferred, def, $ & ambient, bindThis<def>>) => Type<preinferred, $>;
};
declare class _Type<t = unknown, $ = any> extends InnerRoot<t, $> implements internalImplementationOf<Root> {
    $: Scope<$>;
    get in(): Type<this["tIn"], $>;
    get out(): Type<this["tOut"], $>;
    intersect<def>(def: validateTypeRoot<def, $>): Type<inferIntersection<t, inferTypeRoot<def, $>>> | Disjoint;
    and<def>(def: validateTypeRoot<def, $>): Type<inferIntersection<t, inferTypeRoot<def, $>>, $>;
    or<def>(def: validateTypeRoot<def, $>): Type<t | inferTypeRoot<def, $>, $>;
    array(): Type<t[], $>;
    keyof(): Type<keyof this["inferIn"], $>;
    pipe<a extends Morph<this["infer"]>>(a: a): Type<inferPipes<t, [a]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>>(a: a, b: b): Type<inferPipes<t, [a, b]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>>(a: a, b: b, c: c): Type<inferPipes<t, [a, b, c]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>>(a: a, b: b, c: c, d: d): Type<inferPipes<t, [a, b, c, d]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>>(a: a, b: b, c: c, d: d, e: e): Type<inferPipes<t, [a, b, c, d, e]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>>(a: a, b: b, c: c, d: d, e: e, f: f): Type<inferPipes<t, [a, b, c, d, e, f]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g): Type<inferPipes<t, [a, b, c, d, e, f, g]>, $>;
    narrow<def extends Predicate<distillOut<t>>>(def: def): Type<includesMorphs<t> extends true ? (In: this["tIn"]) => Out<inferNarrow<this["tOut"], def>> : inferNarrow<t, def>, $>;
    equals<def>(def: validateTypeRoot<def, $>): this is Type<inferTypeRoot<def>, $>;
    extract<def>(r: validateTypeRoot<def, $>): Type<t, $>;
    exclude<def>(r: validateTypeRoot<def, $>): Type<t, $>;
    extends<def>(other: validateTypeRoot<def, $>): this is Type<inferTypeRoot<def>, $>;
    constrain<kind extends PrimitiveConstraintKind, const def extends NodeSchema<kind>>(kind: conform<kind, constraintKindOf<this["inferIn"]>>, def: def): Type<constrain<t, kind, def>, $>;
}
export interface Type<
/** @ts-expect-error allow instantiation assignment to the base type */
out t = unknown, $ = any> extends _Type<t, $> {
}
export type TypeConstructor<t = unknown, $ = any> = new (def: unknown, $: Scope<$>) => Type<t, $>;
export declare const Type: TypeConstructor;
export type DefinitionParser<$> = <def>(def: validateTypeRoot<def, $>) => def;
export type validateTypeRoot<def, $ = {}> = validateDefinition<def, $ & ambient, bindThis<def>>;
export type inferTypeRoot<def, $ = {}> = inferDefinition<def, $ & ambient, bindThis<def>>;
export {};
