import {
  HYDRATION_END,
  HYDRATION_ERROR,
  HYDRATION_START,
  PassiveDelegatedEvents,
  array_from,
  block,
  branch,
  current_component_context,
  define_property,
  effect_root,
  flush_sync,
  get_descriptor,
  get_proxied_value,
  hydration_failed,
  hydration_mismatch,
  is_array,
  lifecycle_double_unmount,
  pop,
  proxy,
  push,
  render_effect,
  state_proxy_equality_mismatch,
  user_pre_effect,
  validate_component
} from "./chunk-O56VML7M.js";
import {
  DEV
} from "./chunk-IP2U24VQ.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-AXYXVOZD.js";

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_nodes = (
  /** @type {any} */
  null
);
function set_hydrate_nodes(nodes) {
  hydrate_nodes = nodes;
}
function hydrate_anchor(node) {
  var _a, _b;
  if (node.nodeType !== 8) {
    return node;
  }
  var current = (
    /** @type {Node | null} */
    node
  );
  if (
    /** @type {Comment} */
    current.data !== HYDRATION_START
  ) {
    return node;
  }
  var nodes = [];
  var depth = 0;
  while ((current = /** @type {Node} */
  current.nextSibling) !== null) {
    if (current.nodeType === 8) {
      var data = (
        /** @type {Comment} */
        current.data
      );
      if (data === HYDRATION_START) {
        depth += 1;
      } else if (data[0] === HYDRATION_END) {
        if (depth === 0) {
          hydrate_nodes = /** @type {import('#client').TemplateNode[]} */
          nodes;
          return current;
        }
        depth -= 1;
      }
    }
    nodes.push(current);
  }
  let location;
  if (DEV) {
    const loc = (_b = (_a = node.parentNode) == null ? void 0 : _a.__svelte_meta) == null ? void 0 : _b.loc;
    if (loc) {
      location = `${loc.file}:${loc.line}:${loc.column}`;
    }
  }
  hydration_mismatch(location);
  throw HYDRATION_ERROR;
}

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype;
  array_prototype.indexOf = function(item, from_index) {
    const index = indexOf.call(this, item, from_index);
    if (index === -1) {
      const test = indexOf.call(get_proxied_value(this), get_proxied_value(item), from_index);
      if (test !== -1) {
        state_proxy_equality_mismatch("array.indexOf(...)");
        console.trace();
      }
    }
    return index;
  };
  array_prototype.lastIndexOf = function(item, from_index) {
    const index = lastIndexOf.call(this, item, from_index);
    if (index === -1) {
      const test = lastIndexOf.call(get_proxied_value(this), get_proxied_value(item), from_index);
      if (test !== -1) {
        state_proxy_equality_mismatch("array.lastIndexOf(...)");
        console.trace();
      }
    }
    return index;
  };
  array_prototype.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      const test = includes.call(get_proxied_value(this), get_proxied_value(item), from_index);
      if (test) {
        state_proxy_equality_mismatch("array.includes(...)");
        console.trace();
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype.indexOf = indexOf;
    array_prototype.lastIndexOf = lastIndexOf;
    array_prototype.includes = includes;
  };
}
function strict_equals(a, b, equal = true) {
  if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "===" : "!==");
    console.trace();
  }
  return a === b === equal;
}
function equals(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
    console.trace();
  }
  return a == b === equal;
}

// node_modules/svelte/src/internal/client/dom/operations.js
var node_prototype;
var element_prototype;
var text_prototype;
var append_child_method;
var clone_node_method;
var first_child_get;
var next_sibling_get;
var text_content_set;
var class_name_set;
var $window;
var $document;
function init_operations() {
  if (node_prototype !== void 0) {
    return;
  }
  node_prototype = Node.prototype;
  element_prototype = Element.prototype;
  text_prototype = Text.prototype;
  append_child_method = node_prototype.appendChild;
  clone_node_method = node_prototype.cloneNode;
  $window = window;
  $document = document;
  element_prototype.__click = void 0;
  text_prototype.__nodeValue = " ";
  element_prototype.__className = "";
  element_prototype.__attributes = null;
  element_prototype.__e = void 0;
  if (DEV) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
  first_child_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "firstChild").get;
  next_sibling_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "nextSibling").get;
  text_content_set = /** @type {(this: Node, text: string ) => void} */
  // @ts-ignore
  get_descriptor(node_prototype, "textContent").set;
  class_name_set = /** @type {(this: Element, class_name: string) => void} */
  // @ts-ignore
  get_descriptor(element_prototype, "className").set;
}
function append_child(element, child2) {
  append_child_method.call(element, child2);
}
function clone_node(node, deep) {
  return (
    /** @type {N} */
    clone_node_method.call(node, deep)
  );
}
function empty() {
  return document.createTextNode("");
}
function child(node) {
  const child2 = first_child_get.call(node);
  if (!hydrating)
    return child2;
  if (child2 === null) {
    return node.appendChild(empty());
  }
  return hydrate_anchor(child2);
}
function first_child(fragment, is_text) {
  if (!hydrating) {
    return first_child_get.call(
      /** @type {DocumentFragment} */
      fragment
    );
  }
  const first_node = (
    /** @type {import('#client').TemplateNode[]} */
    fragment[0]
  );
  if (is_text && (first_node == null ? void 0 : first_node.nodeType) !== 3) {
    const text = empty();
    hydrate_nodes.unshift(text);
    first_node == null ? void 0 : first_node.before(text);
    return text;
  }
  return hydrate_anchor(first_node);
}
function sibling(node, is_text = false) {
  const next_sibling = next_sibling_get.call(node);
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && (next_sibling == null ? void 0 : next_sibling.nodeType) !== 3) {
    const text = empty();
    if (next_sibling) {
      const index = hydrate_nodes.indexOf(
        /** @type {Text | Comment | Element} */
        next_sibling
      );
      hydrate_nodes.splice(index, 0, text);
      next_sibling.before(text);
    } else {
      hydrate_nodes.push(text);
    }
    return text;
  }
  return hydrate_anchor(
    /** @type {Node} */
    next_sibling
  );
}
function set_class_name(node, class_name) {
  class_name_set.call(node, class_name);
}
function clear_text_content(node) {
  text_content_set.call(node, "");
}
function create_element(name) {
  return document.createElement(name);
}

// node_modules/svelte/src/internal/client/dom/elements/events.js
function replay_events(dom) {
  if (!hydrating)
    return;
  if (dom.onload) {
    dom.removeAttribute("onload");
  }
  if (dom.onerror) {
    dom.removeAttribute("onerror");
  }
  const event2 = dom.__e;
  if (event2 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event2);
      }
    });
  }
}
function event(event_name, dom, handler, capture, passive) {
  var options = { capture, passive };
  function target_handler(event2) {
    if (!capture) {
      handle_event_propagation(dom, event2);
    }
    if (!event2.cancelBubble) {
      return handler.call(this, event2);
    }
  }
  dom.addEventListener(event_name, target_handler, options);
  if (dom === document.body || dom === window || dom === document) {
    render_effect(() => {
      return () => {
        dom.removeEventListener(event_name, target_handler, options);
      };
    });
  }
}
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
function handle_event_propagation(handler_element, event2) {
  var _a;
  var owner_document = handler_element.ownerDocument;
  var event_name = event2.type;
  var path = ((_a = event2.composedPath) == null ? void 0 : _a.call(event2)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  if (event2.target !== current_target) {
    define_property(event2, "target", {
      configurable: true,
      value: current_target
    });
  }
  var path_idx = 0;
  var handled_at = event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx + 1;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  function next(next_target) {
    current_target = next_target;
    var parent_element = next_target.parentNode || /** @type {any} */
    next_target.host || null;
    try {
      var delegated = next_target["__" + event_name];
      if (delegated !== void 0 && !/** @type {any} */
      next_target.disabled) {
        if (is_array(delegated)) {
          var [fn, ...data] = delegated;
          fn.apply(next_target, [event2, ...data]);
        } else {
          delegated.call(next_target, event2);
        }
      }
    } finally {
      if (!event2.cancelBubble && parent_element !== handler_element && parent_element !== null && next_target !== handler_element) {
        next(parent_element);
      }
    }
  }
  try {
    next(current_target);
  } finally {
    event2.__root = handler_element;
    current_target = handler_element;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
var head_anchor;
function reset_head_anchor() {
  head_anchor = void 0;
}
function head(render_fn) {
  let previous_hydrate_nodes = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_nodes = hydrate_nodes;
    if (head_anchor === void 0) {
      head_anchor = /** @type {import('#client').TemplateNode} */
      document.head.firstChild;
    }
    while (head_anchor.nodeType !== 8 || /** @type {Comment} */
    head_anchor.data !== HYDRATION_START) {
      head_anchor = /** @type {import('#client').TemplateNode} */
      head_anchor.nextSibling;
    }
    head_anchor = /** @type {import('#client').TemplateNode} */
    hydrate_anchor(head_anchor);
    head_anchor = /** @type {import('#client').TemplateNode} */
    head_anchor.nextSibling;
  } else {
    anchor = document.head.appendChild(empty());
  }
  try {
    block(() => render_fn(anchor));
  } finally {
    if (was_hydrating) {
      set_hydrate_nodes(
        /** @type {import('#client').TemplateNode[]} */
        previous_hydrate_nodes
      );
    }
  }
}

// node_modules/svelte/src/internal/client/render.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
var should_intro = true;
function set_should_intro(value) {
  should_intro = value;
}
function set_text(dom, value) {
  const prev_node_value = dom.__nodeValue;
  const next_node_value = stringify(value);
  if (hydrating && dom.nodeValue === next_node_value) {
    dom.__nodeValue = next_node_value;
  } else if (prev_node_value !== next_node_value) {
    dom.nodeValue = next_node_value;
    dom.__nodeValue = next_node_value;
  }
}
function slot(anchor, slot_fn, slot_props, fallback_fn) {
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, slot_props);
  }
}
function stringify(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function mount(component, options) {
  if (DEV) {
    validate_component(component);
  }
  const anchor = options.anchor ?? options.target.appendChild(empty());
  return flush_sync(() => _mount(component, { ...options, anchor }), false);
}
function hydrate(component, options) {
  if (DEV) {
    validate_component(component);
  }
  const target = options.target;
  const previous_hydrate_nodes = hydrate_nodes;
  let hydrated = false;
  try {
    return flush_sync(() => {
      set_hydrating(true);
      var node = target.firstChild;
      while (node && (node.nodeType !== 8 || /** @type {Comment} */
      node.data !== HYDRATION_START)) {
        node = node.nextSibling;
      }
      if (!node) {
        throw HYDRATION_ERROR;
      }
      const anchor = hydrate_anchor(node);
      const instance = _mount(component, { ...options, anchor });
      set_hydrating(false);
      hydrated = true;
      return instance;
    }, false);
  } catch (error) {
    if (error === HYDRATION_ERROR) {
      if (options.recover === false) {
        hydration_failed();
      }
      init_operations();
      clear_text_content(target);
      set_hydrating(false);
      return mount(component, options);
    }
    throw error;
  } finally {
    set_hydrating(!!previous_hydrate_nodes);
    set_hydrate_nodes(previous_hydrate_nodes);
    reset_head_anchor();
  }
}
function _mount(Component, { target, anchor, props = {}, events, context, intro = false }) {
  init_operations();
  const registered_events = /* @__PURE__ */ new Set();
  const bound_event_listener = handle_event_propagation.bind(null, target);
  const bound_document_event_listener = handle_event_propagation.bind(null, document);
  const event_handle = (events2) => {
    for (let i = 0; i < events2.length; i++) {
      const event_name = events2[i];
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        target.addEventListener(
          event_name,
          bound_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
        document.addEventListener(
          event_name,
          bound_document_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  let component = void 0;
  const unmount2 = effect_root(() => {
    branch(() => {
      if (context) {
        push({});
        var ctx = (
          /** @type {import('#client').ComponentContext} */
          current_component_context
        );
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      should_intro = intro;
      component = Component(anchor, props) || {};
      should_intro = true;
      if (context) {
        pop();
      }
    });
    return () => {
      for (const event_name of registered_events) {
        target.removeEventListener(event_name, bound_event_listener);
      }
      root_event_handles.delete(event_handle);
      mounted_components.delete(component);
    };
  });
  mounted_components.set(component, unmount2);
  return component;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component) {
  const fn = mounted_components.get(component);
  if (DEV && !fn) {
    lifecycle_double_unmount();
    console.trace("stack trace");
  }
  fn == null ? void 0 : fn();
}
function sanitize_slots(props) {
  const sanitized = { ...props.$$slots };
  if (props.children)
    sanitized.default = props.children;
  return sanitized;
}
async function append_styles(target, style_sheet_id, styles) {
  await Promise.resolve();
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = create_element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_child(
      /** @type {Document} */
      append_styles_to.head || append_styles_to,
      style
    );
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return (
    /** @type {Document} */
    node.ownerDocument
  );
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
function asClassComponent(component) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options) {
      super({
        component,
        ...options
      });
    }
  };
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {import('svelte').ComponentConstructorOptions & {
   *  component: any;
   * 	immutable?: boolean;
   * 	hydrate?: boolean;
   * 	recover?: false;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events, void 0);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance, void 0);
    const props = proxy({ ...options.props || {}, $$events: {} }, false);
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      props,
      context: options.context,
      intro: options.intro,
      recover: options.recover
    }));
    __privateSet(this, _events, props.$$events);
    for (const key of Object.keys(__privateGet(this, _instance))) {
      if (key === "$set" || key === "$destroy" || key === "$on")
        continue;
      define_property(this, key, {
        get() {
          return __privateGet(this, _instance)[key];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next) => {
      Object.assign(props, next);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();
function run(fn) {
  user_pre_effect(fn);
}

export {
  hydrating,
  set_hydrating,
  hydrate_nodes,
  set_hydrate_nodes,
  hydrate_anchor,
  strict_equals,
  equals,
  $window,
  $document,
  clone_node,
  empty,
  child,
  first_child,
  sibling,
  set_class_name,
  clear_text_content,
  replay_events,
  event,
  delegate,
  head,
  should_intro,
  set_should_intro,
  set_text,
  slot,
  stringify,
  mount,
  hydrate,
  unmount,
  sanitize_slots,
  append_styles,
  createClassComponent,
  asClassComponent,
  run
};
//# sourceMappingURL=chunk-N7LUUSXP.js.map
